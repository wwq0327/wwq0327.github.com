<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: web.py | WanQing's Blog]]></title>
  <link href="http://wwq0327.github.com/blog/categories/web-py/atom.xml" rel="self"/>
  <link href="http://wwq0327.github.com/"/>
  <updated>2012-07-15T16:14:27+08:00</updated>
  <id>http://wwq0327.github.com/</id>
  <author>
    <name><![CDATA[wwq0327]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[web.py 添加上下文关联]]></title>
    <link href="http://wwq0327.github.com/blog/2012/06/30/web-dot-py-request/"/>
    <updated>2012-06-30T21:28:00+08:00</updated>
    <id>http://wwq0327.github.com/blog/2012/06/30/web-dot-py-request</id>
    <content type="html"><![CDATA[<p>不清楚这个名字描述得是否准确，我记得在Django中，有个<code>request</code>参数很管用，比如在web设计中，对于用户是否登录的判断，在<code>request</code>中，会自动对<code>request</code>这一关联字传送到模板中去。在web.py中，没有现在的，只能自己想办法了，而还让我找到了这样的代码。</p>

<p>大致做法，一是启动启中加入：</p>

<p>```python
def request_hook():</p>

<pre><code>request = {}
request['user'] = web.ctx.session.username
web.ctx.request = request
</code></pre>

<p>app.add_processor(web.loadhook(request_hook))
```</p>

<p>这里需要开启<code>session</code>功能，后面会用到。</p>

<p>如何进行传递呢，在使用在控制代码中，可以这样定义：</p>

<p>```python
class Index:</p>

<pre><code>def GET(self):
    context = web.ctx.request

return render_template('index.html', **context)
</code></pre>

<p>```</p>

<p>笔者使用的是<code>Jinja2</code>作为<code>web.py</code>板的，这样你在登录后，只对于<code>web.ctx.session.username</code>添加相应的属性，就可以有模板中直接使用<code>user</code>属性了。</p>

<p>代码参考：</p>

<p><a href="https://github.com/wwq0327/qingblog/blob/master/qing/code.py">https://github.com/wwq0327/qingblog/blob/master/qing/code.py</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在web.py中使用Jinja2作模板]]></title>
    <link href="http://wwq0327.github.com/blog/2012/06/26/web-dot-py-jinja2/"/>
    <updated>2012-06-26T23:02:00+08:00</updated>
    <id>http://wwq0327.github.com/blog/2012/06/26/web-dot-py-jinja2</id>
    <content type="html"><![CDATA[<p>Python web开发中，貌似每个框架都能使用不同的模板，我自己知道的模板，如mako, jinja2, Django, web.py自带的模板等。Django上我花过比较多的时间，对于常用的功能还是比较清楚的，在使用web.py进行开发的时候，发现其自带的模板不太习惯，在网上搜索时，发现有人推荐mako，但使用的话又需要重新学习，发现jinja和django的模板差不多，那就用这个了吧。</p>

<p>在web.py的cookbook中有关于其它模板导入示例，如使用jinja：
```python
import web
from web.contrib.template import render_jinja</p>

<p>urls = (</p>

<pre><code>    '/(.*)', 'hello'
    )
</code></pre>

<p>app = web.application(urls, globals())</p>

<p>render = render_jinja(</p>

<pre><code>    'templates',   # Set template directory.
    encoding = 'utf-8',                         # Encoding.
)
</code></pre>

<h1>Add/override some global functions.</h1>

<h1>render._lookup.globals.update(</h1>

<h1>var=newvar,</h1>

<h1>var2=newvar2,</h1>

<h1>)</h1>

<p>class hello:</p>

<pre><code>def GET(self, name):
    return render.hello(name=name)
</code></pre>

<p>if <strong>name</strong> == "<strong>main</strong>":</p>

<pre><code>app.run()
</code></pre>

<p>```</p>

<p>这种方式，在<code>return render.hello(name=name)</code> 时，需与模板名相同，我个人比较喜欢第二种方式：
```python
import os
import web
from jinja2 import Environment,FileSystemLoader</p>

<p>urls = ("/.*", "hello")
app = web.application(urls, globals())</p>

<p>def render_template(template_name, **context):</p>

<pre><code>extensions = context.pop('extensions', [])
globals = context.pop('globals', {})

jinja_env = Environment(
        loader=FileSystemLoader(os.path.join(os.path.dirname(__file__), 'templates')),
        extensions=extensions,
        )
jinja_env.globals.update(globals)

#jinja_env.update_template_context(context)
return jinja_env.get_template(template_name).render(context)
</code></pre>

<p>class hello:</p>

<pre><code>def GET(self):
    # You can use a relative path as template name, for example, 'ldap/hello.html'.
    return render_template('hello.html', name='world',)
</code></pre>

<p>if <strong>name</strong> == "<strong>main</strong>":</p>

<pre><code>app.run()
</code></pre>

<p>```
这种方式和Django的模板方式相似类了。</p>

<p>其实为了方便使用，可以将<code>render_template</code>函数放在一个公共的模块里，然后更接引用即可。</p>

<p>对于<code>render_template</code>参数，可以创建一个字典，如:</p>

<p>```python
class Hello:</p>

<pre><code>def GET(self):
    content = {}
    content['name'] = 'world'
    content['time'] = time
    return render_template('hello.html', **content)
</code></pre>

<p>```</p>

<p>web.py使用起来，参定自我进行定制的地方很多，也正因为这样，可能每个人使用web.py开发出来的应用可以存在着很大的不同，掌握web.py，不仅仅仅于web.py本身，需要学习其它的东西也比较多。Python是挺灵活，但灵活也是有代价的，那就是一个知识点，可以会涉及到很多其它的东西。</p>

<p>但这些很有意思。</p>
]]></content>
  </entry>
  
</feed>
